<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TikTok Slideshow Generator</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- JSZip for handling zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* Apply Inter font to the body */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased; /* Smoother fonts for macOS/iOS feel */
            -moz-osx-font-smoothing: grayscale; /* Smoother fonts for macOS/iOS feel */
        }
        /* Styling for the canvas border and background */
        canvas {
            border: 1px solid #4a5568; /* Slightly lighter border for dark mode */
            background-color: #000000; /* Black background for empty areas */
            /* Added max-height and width to make it responsive on smaller screens */
            max-width: 90vw; /* Max 90% of viewport width */
            max-height: 80vh; /* Max 80% of viewport height to leave space for controls */
            aspect-ratio: 9/16; /* Maintain TikTok's 9:16 aspect ratio */
            width: auto; /* Let width be determined by the aspect ratio */
            height: auto; /* Let height be determined by the aspect ratio */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5); /* Stronger shadow for dark mode depth */
        }

        /* Ensure the canvas scales down for smaller screens */
        @media (max-width: 768px) {
            canvas {
                width: auto; /* Let width be determined by the aspect ratio */
                max-width: 100%; /* Make canvas fill width on small screens */
                aspect-ratio: 9/16; /* Maintain TikTok's 9:16 aspect ratio */
                max-height: 60vh; /* Adjust max height for mobile to fit controls */
            }
        }

        /* Custom iOS-like button dynamics */
        .ios-button {
            transition: all 0.2s ease-in-out;
            transform: translateZ(0); /* For smooth GPU acceleration */
        }
        .ios-button:hover {
            transform: translateY(-2px); /* Slight lift on hover */
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4); /* Enhanced shadow */
        }
        .ios-button:active {
            transform: translateY(0); /* Press down effect */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); /* Subtle shadow when pressed */
            filter: brightness(0.9); /* Slightly darken when pressed */
        }

        /* Custom styling for inputs to fit dark theme */
        input[type="file"]::-webkit-file-upload-button {
            background-color: #4f46e5; /* Indigo-600 */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        input[type="file"]::-webkit-file-upload-button:hover {
            background-color: #4338ca; /* Indigo-700 */
        }
    </style>
</head>
<body class="bg-gray-900 flex items-center justify-center min-h-screen p-4 text-gray-100">
    <div class="bg-gray-800 rounded-xl shadow-2xl p-8 w-full max-w-2xl border border-gray-700">
        <h1 class="text-4xl font-bold text-white mb-8 text-center drop-shadow-lg">TikTok Slideshow Generator</h1>
        
        <!-- Usage Note -->
        <div class="mb-6 bg-blue-900/30 p-4 rounded-lg border border-blue-700/50">
            <h2 class="text-lg font-semibold text-blue-300 mb-2">Usage Note</h2>
            <p class="text-sm text-blue-200">For full functionality, especially folder uploads, this app should be run on a local web server. Simply opening the HTML file directly may limit some features due to browser security restrictions.</p>
        </div>

        <!-- Image Upload Section -->
        <div class="mb-6 bg-gray-700 p-4 rounded-lg shadow-inner">
            <label class="block text-gray-200 text-sm font-bold mb-3" for="imageUpload">
                Upload Images (JPG, PNG)
            </label>
            <div class="flex flex-col space-y-4">
                <div>
                    <input
                        class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-900 text-gray-100 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        id="imageUpload" type="file" accept="image/*" multiple webkitdirectory directory>
                    <p class="text-sm text-gray-400 mt-2">Upload a folder containing images (up to 20 images per folder). Each folder will generate a separate video. Note: This feature requires running the app on a local server.</p>
                </div>
                <div>
                    <input
                        class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-900 text-gray-100 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        id="zipUpload" type="file" accept=".zip" >
                    <p class="text-sm text-gray-400 mt-2">Or upload a ZIP file containing multiple folders of images. Each folder (up to 20 images per folder) will generate a separate video.</p>
                </div>
                <div>
                    <input
                        class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-900 text-gray-100 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        id="singleImageUpload" type="file" accept="image/*" multiple>
                    <p class="text-sm text-gray-400 mt-2">Or upload individual images (up to 20) for a single video.</p>
                </div>
            </div>
            <p class="text-sm text-gray-400 mt-2">Images will be displayed in the 9:16 vertical video frame for TikTok based on your selected fitting mode.</p>
        </div>

        <!-- Video Settings Section (Delay, Duration, and Fitting Mode) -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <div class="bg-gray-700 p-4 rounded-lg shadow-inner">
                <label class="block text-gray-200 text-sm font-bold mb-3" for="imageDelay">
                    Delay Between Images (seconds)
                </label>
                <input
                    class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-900 text-gray-100 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    id="imageDelay" type="number" min="0" max="1" step="0.1" value="0.5">
                <p class="text-sm text-gray-400 mt-2">Adjust time each image is shown (0 to 1 second).</p>
            </div>
            <div class="bg-gray-700 p-4 rounded-lg shadow-inner">
                <label class="block text-gray-200 text-sm font-bold mb-3" for="videoDuration">
                    Total Video Duration (seconds)
                </label>
                <input
                    class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-900 text-gray-100 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    id="videoDuration" type="number" min="1" value="15">
                <p class="text-sm text-gray-400 mt-2">The image sequence will loop to fill this duration.</p>
            </div>
        </div>
        
        <!-- Image Fitting Mode Selection -->
        <div class="mb-6 bg-gray-700 p-4 rounded-lg shadow-inner">
            <label class="block text-gray-200 text-sm font-bold mb-3" for="imageFittingMode">
                Image Fitting Mode
            </label>
            <select
                class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-900 text-gray-100 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                id="imageFittingMode">
                <option value="fill">Fill (Crop to Fill Frame)</option>
                <option value="contain">Contain (Fit Entire Image)</option>
                <option value="cover">Cover (Cover Frame)</option>
                <option value="stretch">Stretch (Stretch to Fill)</option>
            </select>
            <p class="text-sm text-gray-400 mt-2">Choose how images should be displayed in the 9:16 TikTok frame.</p>
        </div>

        <!-- Canvas for Video Preview/Generation -->
        <div class="mb-6 flex justify-center">
            <canvas id="videoCanvas" width="1080" height="1920" class="rounded-lg"></canvas>
        </div>

        <!-- Generate Video Button -->
        <div class="flex justify-center mb-6">
            <button id="generateButton"
                class="ios-button bg-gradient-to-br from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white font-bold py-3 px-8 rounded-full shadow-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800">
                Generate Video
            </button>
        </div>

        <!-- Message Box for User Feedback -->
        <div id="messageBox" class="text-center text-sm text-gray-400 mt-4 hidden p-3 bg-gray-700 rounded-lg"></div>

        <!-- Download Area for Generated Videos -->
        <div id="downloadArea" class="mt-6 text-center hidden">
            <div id="singleDownloadArea">
                <a id="downloadLink"
                   class="ios-button bg-gradient-to-br from-green-500 to-emerald-700 hover:from-green-600 hover:to-emerald-800 text-white font-bold py-3 px-8 rounded-full shadow-lg focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 focus:ring-offset-gray-800 mb-4 inline-block"
                   download="tiktok_slideshow.mp4">
                    Download Video
                </a>
            </div>
            <div id="batchDownloadArea" class="hidden">
                <div id="batchVideoList" class="mb-4 max-h-60 overflow-y-auto bg-gray-900 p-4 rounded-lg text-left">
                    <!-- Batch videos will be listed here -->
                </div>
                <a id="downloadAllLink"
                   class="ios-button bg-gradient-to-br from-purple-500 to-indigo-700 hover:from-purple-600 hover:to-indigo-800 text-white font-bold py-3 px-8 rounded-full shadow-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-gray-800 inline-block"
                   href="#">
                    Download All Videos (.zip)
                </a>
            </div>
        </div>
    </div>

    <!-- JSZip library is already included in the head section -->
    <script>
        // Get references to DOM elements
        const imageUpload = document.getElementById('imageUpload'); // For folder uploads
        const zipUpload = document.getElementById('zipUpload'); // For zip file uploads
        const singleImageUpload = document.getElementById('singleImageUpload'); // For individual image uploads
        const imageDelayInput = document.getElementById('imageDelay');
        const videoDurationInput = document.getElementById('videoDuration');
        const imageFittingModeSelect = document.getElementById('imageFittingMode'); // For image fitting mode
        const generateButton = document.getElementById('generateButton');
        const videoCanvas = document.getElementById('videoCanvas');
        const ctx = videoCanvas.getContext('2d'); // Get 2D rendering context
        const messageBox = document.getElementById('messageBox');
        const downloadArea = document.getElementById('downloadArea');
        const singleDownloadArea = document.getElementById('singleDownloadArea');
        const batchDownloadArea = document.getElementById('batchDownloadArea');
        const batchVideoList = document.getElementById('batchVideoList');
        const downloadLink = document.getElementById('downloadLink');
        const downloadAllLink = document.getElementById('downloadAllLink');

        // State variables
        let uploadedImages = []; // Stores loaded HTMLImageElement objects for current video
        let folderImages = {}; // Object to store images by folder path
        let generatedVideos = []; // Array to store generated video blobs and their names
        let isBatchMode = false; // Flag to indicate if we're in batch processing mode
        let currentFolderIndex = 0; // Index of the folder currently being processed
        let folderPaths = []; // Array of folder paths to process
        let videoRecorder;       // MediaRecorder instance
        let animationFrameId;    // ID for requestAnimationFrame loop
        let currentImageIndex = 0; // Index of the image currently being displayed
        let lastFrameTime = 0;   // Timestamp of the last animation frame
        let totalRecordedTime = 0; // Cumulative time for the video being generated
        let videoDurationMillis = 0; // Total video duration in milliseconds
        let imageDisplayDurationMillis = 0; // How long each image is displayed in milliseconds
        
        // Prevent 404 errors for favicon and meta.json
        window.addEventListener('error', function(e) {
            // Ignore 404 errors for favicon and meta.json
            if (e.target.tagName === 'LINK' && e.target.rel === 'icon') {
                e.preventDefault();
                return false;
            }
            if (e.target.tagName === 'SCRIPT' && e.target.src.includes('meta.json')) {
                e.preventDefault();
                return false;
            }
        }, true);
        let imageSequenceDurationMillis = 0; // Total time for one full loop of all images

        const MAX_IMAGES = 20; // Maximum number of allowed images per folder
        const VIDEO_FPS = 30;  // Frames per second for the output video
        // Define a higher bitrate for even better video quality (e.g., 8 Mbps for a 1080p vertical video)
        const VIDEO_BITRATE = 8 * 1024 * 1024; // 8 Megabits per second

        // Determine the preferred MIME type for video output
        let preferredMimeType = 'video/mp4; codecs=avc1'; // H.264 codec
        let fallbackMimeType = 'video/webm; codecs=vp9';
        let outputExtension = 'mp4';

        // Check if the browser supports the preferred MP4 format
        if (!MediaRecorder.isTypeSupported(preferredMimeType)) {
            preferredMimeType = fallbackMimeType; // Fallback to WebM
            outputExtension = 'webm';
            console.warn('MP4 (H.264) not fully supported by MediaRecorder in this browser. Falling back to WebM (VP9).');
        }

        /**
         * Shows a message in the message box to provide user feedback.
         * @param {string} message - The message text to display.
         * @param {string} type - 'info', 'success', or 'error' to apply appropriate styling.
         */
        function showMessage(message, type = 'info') {
            messageBox.textContent = message;
            // Remove all previous type classes and show the message box
            messageBox.classList.remove('hidden', 'text-blue-600', 'text-green-600', 'text-red-600', 'text-gray-400');
            messageBox.classList.add('block'); // Ensure it's visible

            if (type === 'info') messageBox.classList.add('text-blue-400'); /* Lighter blue for dark theme */
            else if (type === 'success') messageBox.classList.add('text-green-400'); /* Lighter green */
            else if (type === 'error') messageBox.classList.add('text-red-400'); /* Lighter red */
            else messageBox.classList.add('text-gray-400'); /* Default text color */
        }

        /**
         * Hides the message box.
         */
        function hideMessage() {
            messageBox.classList.add('hidden');
        }

        /**
         * Draws an image onto the canvas based on the selected fitting mode.
         * @param {HTMLImageElement} image - The image object to draw.
         */
        function drawResizedImage(image) {
            const canvasWidth = videoCanvas.width;
            const canvasHeight = videoCanvas.height;
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.fillStyle = '#000000'; // Fill with black background
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            const imageAspectRatio = image.width / image.height;
            const canvasAspectRatio = canvasWidth / canvasHeight; // 9:16 for TikTok
            
            // Get the current fitting mode from the select element
            const fittingMode = imageFittingModeSelect.value;
            
            // Variables for source and destination rectangles
            let sx, sy, sWidth, sHeight; // Source rectangle (portion of the image to draw)
            let dx, dy, dWidth, dHeight; // Destination rectangle (where to draw on canvas)
            
            switch(fittingMode) {
                case 'fill': // Crop to fill (original behavior)
                    if (imageAspectRatio > canvasAspectRatio) {
                        // Image is wider than canvas - crop sides
                        sHeight = image.height;
                        sWidth = sHeight * canvasAspectRatio;
                        sx = (image.width - sWidth) / 2;
                        sy = 0;
                    } else {
                        // Image is taller than canvas - crop top/bottom
                        sWidth = image.width;
                        sHeight = sWidth / canvasAspectRatio;
                        sx = 0;
                        sy = (image.height - sHeight) / 2;
                    }
                    // Draw to fill entire canvas
                    ctx.drawImage(image, sx, sy, sWidth, sHeight, 0, 0, canvasWidth, canvasHeight);
                    break;
                    
                case 'contain': // Fit entire image with possible letterboxing
                    if (imageAspectRatio > canvasAspectRatio) {
                        // Image is wider - will have black bars on top and bottom
                        dWidth = canvasWidth;
                        dHeight = dWidth / imageAspectRatio;
                        dx = 0;
                        dy = (canvasHeight - dHeight) / 2;
                    } else {
                        // Image is taller - will have black bars on sides
                        dHeight = canvasHeight;
                        dWidth = dHeight * imageAspectRatio;
                        dx = (canvasWidth - dWidth) / 2;
                        dy = 0;
                    }
                    // Draw the entire image with letterboxing
                    ctx.drawImage(image, 0, 0, image.width, image.height, dx, dy, dWidth, dHeight);
                    break;
                    
                case 'cover': // Cover the entire canvas (similar to fill but ensures the entire canvas is covered)
                    if (imageAspectRatio > canvasAspectRatio) {
                        // Image is wider - scale to match canvas height and crop sides
                        const scale = canvasHeight / image.height;
                        const scaledWidth = image.width * scale;
                        dx = (canvasWidth - scaledWidth) / 2;
                        dy = 0;
                        dWidth = scaledWidth;
                        dHeight = canvasHeight;
                    } else {
                        // Image is taller - scale to match canvas width and crop top/bottom
                        const scale = canvasWidth / image.width;
                        const scaledHeight = image.height * scale;
                        dx = 0;
                        dy = (canvasHeight - scaledHeight) / 2;
                        dWidth = canvasWidth;
                        dHeight = scaledHeight;
                    }
                    // Draw the image to cover the canvas
                    ctx.drawImage(image, 0, 0, image.width, image.height, dx, dy, dWidth, dHeight);
                    break;
                    
                case 'stretch': // Stretch to fill regardless of aspect ratio
                    // Draw the image stretched to fill the entire canvas
                    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvasWidth, canvasHeight);
                    break;
                    
                default: // Default to fill mode
                    if (imageAspectRatio > canvasAspectRatio) {
                        sHeight = image.height;
                        sWidth = sHeight * canvasAspectRatio;
                        sx = (image.width - sWidth) / 2;
                        sy = 0;
                    } else {
                        sWidth = image.width;
                        sHeight = sWidth / canvasAspectRatio;
                        sx = 0;
                        sy = (image.height - sHeight) / 2;
                    }
                    ctx.drawImage(image, sx, sy, sWidth, sHeight, 0, 0, canvasWidth, canvasHeight);
            }
        }

        /**
         * Loads images from files into memory.
         * @param {FileList} files - The files to load.
         * @param {Function} callback - Callback function to call with loaded images array.
         * @param {number} maxImages - Maximum number of images to load.
         * @returns {Promise} - Promise that resolves when all images are loaded.
         */
        function loadImagesFromFiles(files, callback, maxImages = MAX_IMAGES) {
            if (files.length === 0) {
                showMessage('No images selected.', 'info');
                return Promise.reject('No images');
            }
            
            if (files.length > maxImages) {
                showMessage(`Please select a maximum of ${maxImages} images per folder. This folder has ${files.length}.`, 'error');
                return Promise.reject('Too many images');
            }

            const filesArray = Array.from(files); // Convert FileList to an array
            // Create an array to store images in their original selection order
            let loadedImagesOrdered = new Array(filesArray.length);
            let loadedCount = 0;

            // Create an array of Promises, one for each image loading operation
            const loadImagePromises = filesArray.map((file, index) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            loadedImagesOrdered[index] = img; // Place image at its original index
                            loadedCount++;
                            // Check if all images have finished loading
                            if (loadedCount === filesArray.length) {
                                if (callback) {
                                    callback(loadedImagesOrdered);
                                }
                                resolve(loadedImagesOrdered); // Resolve the promise with loaded images
                            }
                        };
                        img.onerror = () => {
                            // Handle image loading errors
                            showMessage(`Could not load image: ${file.name}`, 'error');
                            reject();
                        };
                        img.src = e.target.result; // Set image source to the Data URL
                    };
                    reader.readAsDataURL(file); // Read file as Data URL
                });
            });

            return Promise.all(loadImagePromises);
        }

        /**
         * Handles the file selection event when individual images are uploaded.
         */
        singleImageUpload.addEventListener('change', (event) => {
            uploadedImages = []; // Clear previous images
            folderImages = {}; // Clear folder images
            generatedVideos = []; // Clear generated videos
            isBatchMode = false; // Set to single mode
            downloadArea.classList.add('hidden'); // Hide download area
            singleDownloadArea.classList.remove('hidden'); // Show single download area
            batchDownloadArea.classList.add('hidden'); // Hide batch download area
            hideMessage(); // Clear any existing messages

            const files = event.target.files;
            loadImagesFromFiles(files, (loadedImages) => {
                uploadedImages = loadedImages;
                if (uploadedImages.length > 0) {
                    drawResizedImage(uploadedImages[0]); // Draw the first image as a preview
                }
                showMessage(`${loadedImages.length} images loaded for single video.`, 'success');
            }).catch(() => {
                singleImageUpload.value = ''; // Clear the file input selection
                showMessage('Failed to load images for single video.', 'error');
            });
        });

        /**
         * Handles the file selection event when folders of images are uploaded.
         */
        imageUpload.addEventListener('change', (event) => {
            uploadedImages = []; // Clear previous images
            folderImages = {}; // Clear folder images
            generatedVideos = []; // Clear generated videos
            isBatchMode = true; // Set to batch mode
            downloadArea.classList.add('hidden'); // Hide download area
            singleDownloadArea.classList.add('hidden'); // Hide single download area
            batchDownloadArea.classList.remove('hidden'); // Show batch download area
            hideMessage(); // Clear any existing messages

            const files = event.target.files;
            if (files.length === 0) {
                showMessage('No files selected.', 'info');
                return;
            }

            // Group files by folder path
            const filesByFolder = {};
            Array.from(files).forEach(file => {
                // Get the folder path (everything before the last slash)
                const fullPath = file.webkitRelativePath || file.name;
                const lastSlashIndex = fullPath.lastIndexOf('/');
                const folderPath = lastSlashIndex !== -1 ? fullPath.substring(0, lastSlashIndex) : '';
                
                // Only process image files
                if (file.type.startsWith('image/')) {
                    if (!filesByFolder[folderPath]) {
                        filesByFolder[folderPath] = [];
                    }
                    filesByFolder[folderPath].push(file);
                }
            });

            // Get folder paths and sort them
            folderPaths = Object.keys(filesByFolder).sort();
            
            if (folderPaths.length === 0) {
                showMessage('No folders with images found.', 'error');
                imageUpload.value = ''; // Clear the file input selection
                return;
            }

            // Process each folder
            let totalFolders = folderPaths.length;
            let processedFolders = 0;
            let validFolders = 0;

            folderPaths.forEach(folderPath => {
                const folderFiles = filesByFolder[folderPath];
                
                // Skip folders with too many images
                if (folderFiles.length > MAX_IMAGES) {
                    showMessage(`Folder '${folderPath}' has ${folderFiles.length} images, which exceeds the limit of ${MAX_IMAGES}. It will be skipped.`, 'error');
                    processedFolders++;
                    return;
                }
                
                // Skip folders with no images
                if (folderFiles.length === 0) {
                    processedFolders++;
                    return;
                }

                // Load images for this folder
                loadImagesFromFiles(folderFiles, (loadedImages) => {
                    folderImages[folderPath] = loadedImages;
                    validFolders++;
                    processedFolders++;
                    
                    // If this is the first valid folder, show a preview
                    if (validFolders === 1 && loadedImages.length > 0) {
                        uploadedImages = loadedImages; // Set as current images for preview
                        drawResizedImage(uploadedImages[0]); // Draw the first image as a preview
                    }
                    
                    // Check if all folders have been processed
                    if (processedFolders === totalFolders) {
                        if (validFolders === 0) {
                            showMessage('No valid folders with images found.', 'error');
                            imageUpload.value = ''; // Clear the file input selection
                        } else {
                            showMessage(`${validFolders} folders with images loaded. Ready to generate ${validFolders} videos.`, 'success');
                        }
                    }
                }, MAX_IMAGES).catch(() => {
                    processedFolders++;
                });
            });
        });

        /**
         * Handles the file selection event when a zip file is uploaded.
         */
        zipUpload.addEventListener('change', (event) => {
            uploadedImages = []; // Clear previous images
            folderImages = {}; // Clear folder images
            generatedVideos = []; // Clear generated videos
            isBatchMode = true; // Set to batch mode
            downloadArea.classList.add('hidden'); // Hide download area
            singleDownloadArea.classList.add('hidden'); // Hide single download area
            batchDownloadArea.classList.remove('hidden'); // Show batch download area
            hideMessage(); // Clear any existing messages

            const file = event.target.files[0];
            if (!file) {
                showMessage('No zip file selected.', 'info');
                return;
            }

            showMessage('Processing zip file... This may take a moment.', 'info');

            // Read the zip file
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    // Load the zip file content
                    const zip = await JSZip.loadAsync(e.target.result);
                    
                    // Group files by folder path
                    const filesByFolder = {};
                    const imagePromises = [];
                    
                    // Process each file in the zip
                    zip.forEach((relativePath, zipEntry) => {
                        // Skip directories
                        if (zipEntry.dir) return;
                        
                        // Skip __MACOSX folders and hidden files/folders
                        if (relativePath.startsWith('__MACOSX/') || relativePath.includes('/.') || relativePath.startsWith('.')) return;
                        
                        // Skip non-image files (based on extension)
                        const extension = relativePath.split('.').pop().toLowerCase();
                        const validImageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp'];
                        if (!validImageExtensions.includes(extension)) return;
                        
                        // Get the folder path (everything before the last slash)
                        const lastSlashIndex = relativePath.lastIndexOf('/');
                        const folderPath = lastSlashIndex !== -1 ? relativePath.substring(0, lastSlashIndex) : '';
                        const fileName = lastSlashIndex !== -1 ? relativePath.substring(lastSlashIndex + 1) : relativePath;
                        
                        // Initialize folder array if needed
                        if (!filesByFolder[folderPath]) {
                            filesByFolder[folderPath] = [];
                        }
                        
                        // Add a promise to extract and process this file
                        const promise = zipEntry.async('blob').then(blob => {
                            // Create a File object from the blob
                            const file = new File([blob], fileName, { type: `image/${extension === 'jpg' ? 'jpeg' : extension}` });
                            filesByFolder[folderPath].push(file);
                        });
                        
                        imagePromises.push(promise);
                    });
                    
                    // Wait for all files to be processed
                    await Promise.all(imagePromises);
                    
                    // Get folder paths and sort them
                    folderPaths = Object.keys(filesByFolder).sort();
                    
                    if (folderPaths.length === 0) {
                        showMessage('No folders with images found in the zip file.', 'error');
                        zipUpload.value = ''; // Clear the file input selection
                        return;
                    }
                    
                    // Process each folder
                    let totalFolders = folderPaths.length;
                    let processedFolders = 0;
                    let validFolders = 0;
                    
                    const processFolderPromises = folderPaths.map(folderPath => {
                        return new Promise(resolve => {
                            const folderFiles = filesByFolder[folderPath];
                            
                            // Skip folders with too many images
                            if (folderFiles.length > MAX_IMAGES) {
                                showMessage(`Folder '${folderPath}' has ${folderFiles.length} images, which exceeds the limit of ${MAX_IMAGES}. It will be skipped.`, 'error');
                                processedFolders++;
                                resolve();
                                return;
                            }
                            
                            // Skip folders with no images
                            if (folderFiles.length === 0) {
                                processedFolders++;
                                resolve();
                                return;
                            }
                            
                            // Load images for this folder
                            loadImagesFromFiles(folderFiles, (loadedImages) => {
                                folderImages[folderPath] = loadedImages;
                                validFolders++;
                                processedFolders++;
                                
                                // If this is the first valid folder, show a preview
                                if (validFolders === 1 && loadedImages.length > 0) {
                                    uploadedImages = loadedImages; // Set as current images for preview
                                    drawResizedImage(uploadedImages[0]); // Draw the first image as a preview
                                }
                                
                                resolve();
                            }, MAX_IMAGES).catch(() => {
                                processedFolders++;
                                resolve();
                            });
                        });
                    });
                    
                    // Wait for all folders to be processed
                    await Promise.all(processFolderPromises);
                    
                    // Show final message
                    if (validFolders === 0) {
                        showMessage('No valid folders with images found in the zip file.', 'error');
                        zipUpload.value = ''; // Clear the file input selection
                    } else {
                        showMessage(`${validFolders} folders with images loaded from zip file. Ready to generate ${validFolders} videos.`, 'success');
                    }
                    
                } catch (error) {
                    console.error('Error processing zip file:', error);
                    showMessage('Error processing zip file. Please make sure it is a valid zip file.', 'error');
                    zipUpload.value = ''; // Clear the file input selection
                }
            };
            
            reader.onerror = () => {
                showMessage('Error reading the zip file.', 'error');
                zipUpload.value = ''; // Clear the file input selection
            };
            
            reader.readAsArrayBuffer(file);
        });

        /**
         * The main animation loop that updates the canvas with images for video generation.
         * It's responsible for drawing the correct image based on the elapsed video time.
         * @param {DOMHighResTimeStamp} currentTime - The timestamp provided by requestAnimationFrame.
         */
        function animate(currentTime) {
            // Initialize lastFrameTime if this is the first call
            if (!lastFrameTime) {
                lastFrameTime = currentTime;
            }

            // Calculate the desired interval for each video frame
            const frameInterval = 1000 / VIDEO_FPS; // e.g., ~33.33ms for 30 FPS

            // Check if enough time has passed to render the next video frame
            // This ensures that the canvas updates at a rate consistent with the video's FPS
            if (currentTime - lastFrameTime >= frameInterval) {
                // Advance the 'conceptual' video time by one frame duration
                totalRecordedTime += frameInterval;
                lastFrameTime = currentTime; // Reset lastFrameTime for the next interval

                // Check if the total video duration has been reached
                if (totalRecordedTime >= videoDurationMillis) {
                    // Stop the animation and the MediaRecorder
                    cancelAnimationFrame(animationFrameId);
                    if (videoRecorder && videoRecorder.state === 'recording') {
                        videoRecorder.stop();
                    }
                    showMessage('Video generation complete!', 'success');
                    return; // Exit the function as video generation is done
                }

                // If images are uploaded, determine and draw the current image
                if (uploadedImages.length > 0) {
                    // Calculate the effective time within one full sequence of images
                    const effectiveTimeInSequence = totalRecordedTime % imageSequenceDurationMillis;

                    // Calculate the current image index based on the effective time and individual image display duration
                    currentImageIndex = Math.floor(effectiveTimeInSequence / imageDisplayDurationMillis);

                    // Ensure the image index does not exceed the bounds of the uploadedImages array
                    currentImageIndex = Math.min(currentImageIndex, uploadedImages.length - 1);

                    // Draw the calculated current image to the canvas
                    drawResizedImage(uploadedImages[currentImageIndex]);
                } else {
                    // If no images are present, stop everything and show an error
                    cancelAnimationFrame(animationFrameId);
                    if (videoRecorder && videoRecorder.state === 'recording') {
                        videoRecorder.stop();
                    }
                    showMessage('No images to generate video from.', 'error');
                    return;
                }
            }
            // Request the next animation frame, regardless of whether a new image was drawn in this specific call.
            // This ensures the loop continues to check for frame updates.
            animationFrameId = requestAnimationFrame(animate);
        }

        /**
         * Generates a single video from the provided images.
         * @param {Array} images - Array of image objects to use for the video.
         * @param {string} videoName - Name for the generated video file.
         * @returns {Promise} - Promise that resolves with the generated video blob.
         */
        function generateVideo(images, videoName) {
            return new Promise((resolve, reject) => {
                if (images.length === 0) {
                    reject('No images provided');
                    return;
                }

                // Get and validate user inputs
                const imageDelay = parseFloat(imageDelayInput.value);
                const videoDuration = parseFloat(videoDurationInput.value);

                if (isNaN(imageDelay) || imageDelay < 0 || imageDelay > 1) {
                    reject('Invalid image delay');
                    return;
                }
                if (isNaN(videoDuration) || videoDuration < 1) {
                    reject('Invalid video duration');
                    return;
                }

                // Convert durations to milliseconds
                videoDurationMillis = videoDuration * 1000;
                imageDisplayDurationMillis = imageDelay * 1000;

                // If image delay is 0, set a minimum display duration per image to ensure it's visible for at least one frame
                if (imageDisplayDurationMillis === 0) {
                    imageDisplayDurationMillis = 1000 / VIDEO_FPS;
                }

                // Calculate the total duration for one full sequence of all images
                imageSequenceDurationMillis = images.length * imageDisplayDurationMillis;

                // Handle edge case where sequence duration might be zero
                if (imageSequenceDurationMillis === 0) {
                    reject('Invalid sequence duration');
                    return;
                }

                // Set the current images for the animation loop
                uploadedImages = images;
                
                // Draw the first image as a preview
                if (images.length > 0) {
                    drawResizedImage(images[0]);
                }

                // Reset state for a new recording session
                currentImageIndex = 0;
                lastFrameTime = 0;
                totalRecordedTime = 0;
                
                // Cancel any previously running animation frame
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }

                // --- MediaRecorder Setup ---
                // Get a MediaStream from the canvas, setting the desired FPS for the video output
                const stream = videoCanvas.captureStream(VIDEO_FPS);
                // Define recording options based on supported MIME type, including a higher bitrate
                const options = { mimeType: preferredMimeType, videoBitsPerSecond: VIDEO_BITRATE };

                const chunks = []; // Array to store video data chunks

                // Create a new MediaRecorder instance
                videoRecorder = new MediaRecorder(stream, options);

                // Event handler for when data chunks are available
                videoRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        chunks.push(event.data);
                    }
                };

                // Event handler for when the recording stops
                videoRecorder.onstop = () => {
                    // Create a Blob from the collected data chunks
                    const blob = new Blob(chunks, { type: preferredMimeType });
                    resolve({ blob, name: videoName });
                };

                // Event handler for recording errors
                videoRecorder.onerror = (event) => {
                    console.error('MediaRecorder error:', event);
                    reject('MediaRecorder error');
                };

                // Start the MediaRecorder, indicating that data should be collected at the desired frame rate
                videoRecorder.start(1000 / VIDEO_FPS); // Collect data every X milliseconds
                // Start the requestAnimationFrame loop which drives the canvas drawing
                animationFrameId = requestAnimationFrame(animate);
            });
        }

        /**
         * Processes the next folder in batch mode.
         */
        function processNextFolder() {
            if (currentFolderIndex >= folderPaths.length) {
                // All folders processed
                showMessage(`All ${generatedVideos.length} videos generated successfully!`, 'success');
                
                // Display the list of generated videos
                displayGeneratedVideos();
                
                // Re-enable UI elements
                generateButton.disabled = false;
                imageUpload.disabled = false;
                singleImageUpload.disabled = false;
                imageDelayInput.disabled = false;
                videoDurationInput.disabled = false;
                
                // Show download area
                downloadArea.classList.remove('hidden');
                singleDownloadArea.classList.add('hidden');
                batchDownloadArea.classList.remove('hidden');
                return;
            }

            const folderPath = folderPaths[currentFolderIndex];
            const folderImagesForPath = folderImages[folderPath];
            
            if (!folderImagesForPath || folderImagesForPath.length === 0) {
                // Skip empty folders
                currentFolderIndex++;
                processNextFolder();
                return;
            }

            // Get folder name from path
            const folderName = folderPath.split('/').pop() || folderPath;
            showMessage(`Generating video ${currentFolderIndex + 1} of ${folderPaths.length}: ${folderName}...`, 'info');

            // Generate video for this folder
            generateVideo(folderImagesForPath, `${folderName}.${outputExtension}`)
                .then(result => {
                    // Add to generated videos
                    generatedVideos.push(result);
                    currentFolderIndex++;
                    processNextFolder();
                })
                .catch(error => {
                    console.error('Error generating video:', error);
                    showMessage(`Error generating video for folder ${folderName}. Skipping.`, 'error');
                    currentFolderIndex++;
                    processNextFolder();
                });
        }

        /**
         * Displays the list of generated videos in the batch video list.
         */
        function displayGeneratedVideos() {
            batchVideoList.innerHTML = '';
            
            generatedVideos.forEach((video, index) => {
                const videoUrl = URL.createObjectURL(video.blob);
                
                const videoItem = document.createElement('div');
                videoItem.className = 'flex justify-between items-center p-2 hover:bg-gray-800 rounded';
                
                const videoName = document.createElement('span');
                videoName.textContent = video.name;
                videoName.className = 'text-gray-200';
                
                const downloadButton = document.createElement('a');
                downloadButton.href = videoUrl;
                downloadButton.download = video.name;
                downloadButton.className = 'ios-button bg-gradient-to-br from-green-500 to-emerald-700 hover:from-green-600 hover:to-emerald-800 text-white text-sm font-bold py-1 px-3 rounded-full shadow-sm focus:outline-none';
                downloadButton.textContent = 'Download';
                
                videoItem.appendChild(videoName);
                videoItem.appendChild(downloadButton);
                batchVideoList.appendChild(videoItem);
            });
        }

        /**
         * Creates a zip file containing all generated videos.
         */
        function createVideoZip() {
            const zip = new JSZip();
            
            // Add each video to the zip file
            const promises = generatedVideos.map((video, index) => {
                return new Promise((resolve) => {
                    zip.file(video.name, video.blob);
                    resolve();
                });
            });
            
            // When all videos are added, generate the zip file
            Promise.all(promises).then(() => {
                zip.generateAsync({ type: 'blob' }).then(content => {
                    // Create a download link for the zip file
                    const zipUrl = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = zipUrl;
                    a.download = 'tiktok_slideshows.zip';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                });
            });
        }

        // Set up the download all link
        downloadAllLink.addEventListener('click', (event) => {
            event.preventDefault();
            createVideoZip();
        });

        /**
         * Initiates the video generation process.
         * Handles both single video and batch mode.
         */
        generateButton.addEventListener('click', () => {
            // Validate common inputs
            const imageDelay = parseFloat(imageDelayInput.value);
            const videoDuration = parseFloat(videoDurationInput.value);

            if (isNaN(imageDelay) || imageDelay < 0 || imageDelay > 1) {
                showMessage('Please enter a valid image delay between 0 and 1 seconds.', 'error');
                return;
            }
            if (isNaN(videoDuration) || videoDuration < 1) {
                showMessage('Please enter a valid video duration (minimum 1 second).', 'error');
                return;
            }

            // Disable UI elements during generation
            generateButton.disabled = true;
            imageUpload.disabled = true;
            singleImageUpload.disabled = true;
            imageDelayInput.disabled = true;
            videoDurationInput.disabled = true;
            downloadArea.classList.add('hidden'); // Hide previous download link

            if (isBatchMode) {
                // Batch mode - process multiple folders
                if (Object.keys(folderImages).length === 0) {
                    showMessage('Please upload folders with images first.', 'error');
                    generateButton.disabled = false;
                    imageUpload.disabled = false;
                    singleImageUpload.disabled = false;
                    imageDelayInput.disabled = false;
                    videoDurationInput.disabled = false;
                    return;
                }
                
                // Reset batch processing state
                currentFolderIndex = 0;
                generatedVideos = [];
                
                // Start processing folders
                showMessage(`Starting batch processing of ${folderPaths.length} folders...`, 'info');
                processNextFolder();
            } else {
                // Single video mode
                if (uploadedImages.length === 0) {
                    showMessage('Please upload images first.', 'error');
                    generateButton.disabled = false;
                    imageUpload.disabled = false;
                    singleImageUpload.disabled = false;
                    imageDelayInput.disabled = false;
                    videoDurationInput.disabled = false;
                    return;
                }
                
                showMessage('Generating video... Please wait. This may take a moment.', 'info');
                
                // Generate a single video
                generateVideo(uploadedImages, `tiktok_slideshow.${outputExtension}`)
                    .then(result => {
                        // Create a URL for the Blob
                        const videoUrl = URL.createObjectURL(result.blob);
                        downloadLink.href = videoUrl; // Set the download link's href
                        downloadLink.download = result.name; // Set the download filename
                        downloadArea.classList.remove('hidden'); // Show the download area
                        singleDownloadArea.classList.remove('hidden'); // Show single download area
                        batchDownloadArea.classList.add('hidden'); // Hide batch download area
                        showMessage(`Video generated successfully as .${outputExtension}! Click "Download Video" below.`, 'success');
                        
                        // Re-enable UI elements
                        generateButton.disabled = false;
                        imageUpload.disabled = false;
                        singleImageUpload.disabled = false;
                        imageDelayInput.disabled = false;
                        videoDurationInput.disabled = false;
                    })
                    .catch(error => {
                        console.error('Error generating video:', error);
                        showMessage('An error occurred during video recording. Please try again.', 'error');
                        
                        // Re-enable UI elements on error
                        generateButton.disabled = false;
                        imageUpload.disabled = false;
                        singleImageUpload.disabled = false;
                        imageDelayInput.disabled = false;
                        videoDurationInput.disabled = false;
                    });
            }
        });

        // Add event listener for image fitting mode changes
        imageFittingModeSelect.addEventListener('change', () => {
            // If there's an image already uploaded, redraw it with the new fitting mode
            if (uploadedImages.length > 0) {
                drawResizedImage(uploadedImages[0]);
            }
        });

        // Initial drawing on the canvas when the page loads
        ctx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
        ctx.fillStyle = '#000000'; // Set background color to black
        ctx.fillRect(0, 0, videoCanvas.width, videoCanvas.height);
        ctx.font = '30px Inter'; // Set font for placeholder text
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#9ca3af'; /* Gray-400 for dark mode */
        ctx.fillText('Upload images to start', videoCanvas.width / 2, videoCanvas.height / 2 - 30);
        ctx.font = '22px Inter';
        ctx.fillText('(Images will be displayed based on fitting mode)', videoCanvas.width / 2, videoCanvas.height / 2 + 10);
    </script>
</body>
</html>
